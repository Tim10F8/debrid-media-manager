generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

model Cache {
  key       String   @id
  value     Json
  updatedAt DateTime @updatedAt
}

model Scraped {
  key       String   @id
  value     Json
  updatedAt DateTime @updatedAt
}

model ScrapedTrue {
  key       String   @id
  value     Json
  updatedAt DateTime @updatedAt
}

model Search {
  key       String   @id
  value     Json
  updatedAt DateTime @updatedAt
}

model Cast {
  id        String   @id @default(uuid())
  imdbId    String
  userId    String
  hash      String
  url       String   @db.Text
  updatedAt DateTime @updatedAt
  size      BigInt   @default(0)
  link      String?

  @@unique([imdbId, userId, hash])
  @@index([imdbId, userId, updatedAt])
}

model CastProfile {
  userId            String   @id
  clientId          String
  clientSecret      String
  updatedAt         DateTime @updatedAt
  refreshToken      String
  movieMaxSize      Float    @default(0)
  episodeMaxSize    Float    @default(0)
  otherStreamsLimit Int      @default(5)
}

model Titles {
  imdbid            String  @id
  title             String
  is_original_title Boolean
  year              Int

  @@unique([imdbid, is_original_title])
  @@unique([imdbid, title])
}

model Anime {
  id              Int     @id @default(autoincrement())
  anidb_id        Int?    @unique
  anime_planet_id String? @unique
  kitsu_id        Int?    @unique
  mal_id          Int?    @unique
  imdb_id         String? @unique
  title           String
  type            String
  aliases         Json
  description     String  @db.Text
  poster_url      String
  background_url  String
  rating          Float

  @@index([anidb_id])
  @@index([anime_planet_id])
  @@index([kitsu_id])
  @@index([mal_id])
  @@index([imdb_id])
}

model Available {
  hash             String          @id
  imdbId           String
  filename         String
  originalFilename String
  bytes            BigInt
  originalBytes    BigInt
  host             String
  progress         Int
  status           String
  ended            DateTime
  updatedAt        DateTime        @updatedAt
  season           Int?
  episode          Int?
  files            AvailableFile[]

  @@index([status])
  @@index([imdbId])
  @@index([imdbId, hash])
  @@index([imdbId, status, season, episode, bytes])
}

model AvailableFile {
  link      String    @id
  file_id   Int
  hash      String
  path      String    @db.Text
  bytes     BigInt
  season    Int?
  episode   Int?
  available Available @relation(fields: [hash], references: [hash], onDelete: Cascade)

  @@index([hash])
  @@index([hash, season, episode])
}

model AvailableAd {
  hash              String            @id
  imdbId            String
  filename          String
  originalFilename  String
  bytes             BigInt
  originalBytes     BigInt
  host              String
  progress          Int
  status            String
  statusCode        Int?
  ended             DateTime
  updatedAt         DateTime          @updatedAt
  createdAt         DateTime          @default(now())
  season            Int?
  episode           Int?
  verifiedAt        DateTime          @default(now())
  verificationCount Int               @default(1)
  files             AvailableAdFile[]

  @@index([status])
  @@index([imdbId])
  @@index([imdbId, hash])
  @@index([imdbId, status, season, episode, bytes])
  @@index([updatedAt])
}

model AvailableAdFile {
  link        String      @id
  file_id     Int
  hash        String
  path        String      @db.Text
  bytes       BigInt
  season      Int?
  episode     Int?
  availableAd AvailableAd @relation(fields: [hash], references: [hash], onDelete: Cascade)

  @@index([hash])
  @@index([hash, season, episode])
}

model User {
  id        Int     @id @default(autoincrement())
  patreonId String? @unique
  githubId  String? @unique
  discordId String? @unique

  patreonSubscription PatreonSubscription?
}

model PatreonSubscription {
  id               Int      @id @default(autoincrement())
  tier             String
  perks            String
  subscriptionDate DateTime @default(now())

  userId Int  @unique
  user   User @relation(fields: [userId], references: [id])
}

model Report {
  id        Int      @id @default(autoincrement())
  hash      String
  imdbId    String
  userId    String
  type      String // "porn" or "wrong_imdb" or "wrong_season"
  createdAt DateTime @default(now())

  @@unique([hash, userId])
  @@index([imdbId])
  @@index([hash])
}

model TrackerStats {
  hash               String   @id
  seeders            Int      @default(0)
  leechers           Int      @default(0)
  downloads          Int      @default(0)
  successfulTrackers Int      @default(0)
  totalTrackers      Int      @default(0)
  lastChecked        DateTime @default(now())

  @@index([lastChecked])
}

model TorrentSnapshot {
  id        String   @id
  hash      String
  addedDate DateTime
  payload   Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([hash])
  @@index([hash, addedDate])
}

model MdblistCache {
  id        String   @id
  type      String // "movie", "show", "search", "list", etc.
  data      Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([type])
  @@index([updatedAt])
}

model ZurgKeys {
  apiKey     String   @id
  validUntil DateTime
  createdAt  DateTime @default(now())

  @@index([validUntil])
}

// Real-Debrid operational events for observability
// Stores individual API call results for the sliding window
model RdOperationalEvent {
  id        Int      @id @default(autoincrement())
  operation String   // e.g., "GET /user", "GET /torrents"
  status    Int      // HTTP status code
  createdAt DateTime @default(now())

  @@index([operation])
  @@index([createdAt])
  @@index([operation, status])
}

// Stream server health check results
// Stores the latest health check for each server
model StreamServerHealth {
  host      String   @id // e.g., "1.download.real-debrid.com"
  status    Int?
  latencyMs Float?
  ok        Boolean  @default(false)
  error     String?  @db.Text
  checkedAt DateTime
  updatedAt DateTime @updatedAt

  @@index([ok])
  @@index([latencyMs])
  @@index([checkedAt])
}

// ═══════════════════════════════════════════════════════════════
// HISTORICAL DATA FOR 90-DAY OBSERVABILITY
// ═══════════════════════════════════════════════════════════════

// RD Operations - Hourly aggregates (kept for 7 days, then rolled into daily)
model RdOperationalHourly {
  id           Int      @id @default(autoincrement())
  hour         DateTime // Start of hour (UTC), e.g., 2024-01-15T14:00:00Z
  operation    String   // "GET /user", "GET /torrents", etc.
  totalCount   Int      // Total requests in this hour
  successCount Int      // 2xx responses
  failureCount Int      // 5xx responses
  otherCount   Int      @default(0) // 3xx, 4xx (not counted in availability)
  successRate  Float    // Pre-computed: successCount / (successCount + failureCount)
  createdAt    DateTime @default(now())

  @@unique([hour, operation])
  @@index([hour])
  @@index([operation, hour])
}

// RD Operations - Daily aggregates (kept for 90 days)
model RdOperationalDaily {
  id             Int      @id @default(autoincrement())
  date           DateTime // Start of day (UTC)
  operation      String
  totalCount     Int      // Sum of hourly totals
  successCount   Int
  failureCount   Int
  avgSuccessRate Float    // Average of hourly success rates
  minSuccessRate Float    // Worst hour of the day
  maxSuccessRate Float    // Best hour of the day
  peakHour       Int?     // Hour with most traffic (0-23)
  createdAt      DateTime @default(now())

  @@unique([date, operation])
  @@index([date])
  @@index([operation, date])
}

// Stream Health - Hourly snapshots (kept for 7 days)
model StreamHealthHourly {
  id             Int      @id @default(autoincrement())
  hour           DateTime // Start of hour (UTC)
  totalServers   Int      // Always 360
  workingServers Int      // How many passed all 3 iterations
  workingRate    Float    // workingServers / totalServers
  avgLatencyMs   Float?   // Average latency of working servers
  minLatencyMs   Float?   // Fastest server latency
  maxLatencyMs   Float?   // Slowest working server latency
  fastestServer  String?  // Hostname of fastest server
  checksInHour   Int      @default(1) // Number of checks aggregated
  failedServers  Json     @default("[]") // Array of failed server hostnames
  createdAt      DateTime @default(now())

  @@unique([hour])
  @@index([hour])
}

// Stream Health - Daily aggregates (kept for 90 days)
model StreamHealthDaily {
  id             Int      @id @default(autoincrement())
  date           DateTime // Start of day (UTC)
  avgWorkingRate Float    // Average % of servers working across all checks
  minWorkingRate Float    // Worst check of the day
  maxWorkingRate Float    // Best check of the day
  avgLatencyMs   Float?   // Average latency across all checks
  checksCount    Int      // Total health checks that day
  alwaysWorking  Int      @default(0) // Servers that never failed
  neverWorking   Int      @default(0) // Servers that never worked
  flaky          Int      @default(0) // Intermittent servers
  createdAt      DateTime @default(now())

  @@unique([date])
  @@index([date])
}

// Per-server daily reliability (for server-level analysis)
model ServerReliabilityDaily {
  id           Int      @id @default(autoincrement())
  date         DateTime
  host         String   // Server hostname
  checksCount  Int      // Times checked
  successCount Int      // Times it was working
  avgLatencyMs Float?   // Average latency when working
  reliability  Float    // successCount / checksCount
  createdAt    DateTime @default(now())

  @@unique([date, host])
  @@index([date])
  @@index([host])
  @@index([reliability])
}
