generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

model Cache {
  key       String   @id
  value     Json
  updatedAt DateTime @updatedAt
}

model Scraped {
  key       String   @id
  value     Json
  updatedAt DateTime @updatedAt
}

model ScrapedTrue {
  key       String   @id
  value     Json
  updatedAt DateTime @updatedAt
}

// ═══════════════════════════════════════════════════════════════
// MUSIC DATA TABLES (MusicBrainz Integration)
// ═══════════════════════════════════════════════════════════════

// Scraped music torrents, keyed by MusicBrainz release-group ID
// Key format: "music:{mbid}" where mbid is the release-group UUID
// Value: JSON array of {hash, title, fileSize, format, tracks}
model ScrapedMusic {
  key       String   @id // "music:{mbid}"
  value     Json // Array of torrent entries
  updatedAt DateTime @updatedAt

  @@index([updatedAt])
}

// Music metadata from MusicBrainz
model MusicMetadata {
  mbid       String   @id @db.VarChar(36) // MusicBrainz release-group UUID
  artistMbid String?  @db.VarChar(36) // MusicBrainz artist UUID
  artist     String   @db.VarChar(500)
  album      String   @db.VarChar(500)
  year       Int?
  coverUrl   String?  @db.VarChar(500) // Album cover URL from iTunes
  updatedAt  DateTime @updatedAt

  @@index([artist])
  @@index([year])
  @@fulltext([artist, album])
}

// Available music torrents (cached in debrid service)
model AvailableMusic {
  hash             String               @id
  mbid             String               @db.VarChar(36) // MusicBrainz release-group UUID
  filename         String
  originalFilename String
  bytes            BigInt
  originalBytes    BigInt
  host             String               // "rd", "ad", "tb"
  progress         Int
  status           String
  ended            DateTime
  updatedAt        DateTime             @updatedAt
  files            AvailableMusicFile[]

  @@index([status])
  @@index([mbid])
  @@index([mbid, hash])
  @@index([mbid, status, bytes])
}

// Files within available music torrents
model AvailableMusicFile {
  link           String         @id
  file_id        Int
  hash           String
  path           String         @db.Text
  bytes          BigInt
  trackNumber    Int?           // Track number if detectable
  availableMusic AvailableMusic @relation(fields: [hash], references: [hash], onDelete: Cascade)

  @@index([hash])
}

model Search {
  key       String   @id
  value     Json
  updatedAt DateTime @updatedAt
}

model Cast {
  id        String   @id @default(uuid())
  imdbId    String
  userId    String
  hash      String
  url       String   @db.Text
  updatedAt DateTime @updatedAt
  size      BigInt   @default(0)
  link      String?

  @@unique([imdbId, userId, hash])
  @@index([imdbId, userId, updatedAt])
}

model CastProfile {
  userId            String   @id
  clientId          String
  clientSecret      String
  updatedAt         DateTime @updatedAt
  refreshToken      String
  movieMaxSize      Float    @default(0)
  episodeMaxSize    Float    @default(0)
  otherStreamsLimit Int      @default(5)
  hideCastOption    Boolean  @default(false)
}

// ═══════════════════════════════════════════════════════════════
// TORBOX CAST TABLES (DMM Cast for TorBox)
// ═══════════════════════════════════════════════════════════════

// TorBox Cast - stores individual casted content
model TorBoxCast {
  id        String   @id @default(uuid())
  imdbId    String           // IMDB ID (format: tt1234567 or tt1234567:S:E)
  userId    String           // 12-character hashed user ID (from TorBox email)
  hash      String           // Torrent hash
  url       String   @db.Text // Torrent name/filename for display
  updatedAt DateTime @updatedAt
  size      BigInt   @default(0)  // File size in MB
  link      String?  @db.Text     // TorBox permalink URL
  torrentId Int?             // TorBox torrent ID (for reference)
  fileId    Int?             // TorBox file ID within torrent

  @@unique([imdbId, userId, hash])
  @@index([imdbId, userId, updatedAt])
}

// TorBox Cast Profile - stores user API key and preferences
model TorBoxCastProfile {
  userId            String   @id    // 12-character hashed user ID
  apiKey            String   @db.Text // TorBox API key (stored securely)
  updatedAt         DateTime @updatedAt
  movieMaxSize      Float    @default(0)   // Max movie size filter (GB)
  episodeMaxSize    Float    @default(0)   // Max episode size filter (GB)
  otherStreamsLimit Int      @default(5)   // Max community streams (0-5)
  hideCastOption    Boolean  @default(false) // Hide "Cast a file" option in Stremio
}

// ═══════════════════════════════════════════════════════════════
// ALLDEBRID CAST TABLES (DMM Cast for AllDebrid)
// ═══════════════════════════════════════════════════════════════

// AllDebrid Cast - stores individual casted content
model AllDebridCast {
  id        String   @id @default(uuid())
  imdbId    String           // IMDB ID (format: tt1234567 or tt1234567:S:E)
  userId    String           // 12-character hashed user ID (from AD username)
  hash      String           // Torrent hash
  url       String   @db.Text // Filename for display
  updatedAt DateTime @updatedAt
  size      BigInt   @default(0)  // File size in MB
  link      String?  @db.Text     // Direct download link (expires)
  magnetId  Int?             // AllDebrid magnet ID (for re-fetching links)
  fileIndex Int?             // File index within flattened file list

  @@unique([imdbId, userId, hash])
  @@index([imdbId, userId, updatedAt])
}

// AllDebrid Cast Profile - stores user API key and preferences
model AllDebridCastProfile {
  userId            String   @id    // 12-character hashed user ID
  apiKey            String   @db.Text // AllDebrid API key (stored securely)
  updatedAt         DateTime @updatedAt
  movieMaxSize      Float    @default(0)   // Max movie size filter (GB)
  episodeMaxSize    Float    @default(0)   // Max episode size filter (GB)
  otherStreamsLimit Int      @default(5)   // Max community streams (0-5)
  hideCastOption    Boolean  @default(false) // Hide "Cast a file" option in Stremio
}

model Titles {
  imdbid            String  @id
  title             String
  is_original_title Boolean
  year              Int

  @@unique([imdbid, is_original_title])
  @@unique([imdbid, title])
}

model Anime {
  id              Int     @id @default(autoincrement())
  anidb_id        Int?    @unique
  anime_planet_id String? @unique
  kitsu_id        Int?    @unique
  mal_id          Int?    @unique
  imdb_id         String? @unique
  title           String
  type            String
  aliases         Json
  description     String  @db.Text
  poster_url      String
  background_url  String
  rating          Float

  @@index([anidb_id])
  @@index([anime_planet_id])
  @@index([kitsu_id])
  @@index([mal_id])
  @@index([imdb_id])
}

model Available {
  hash             String          @id
  imdbId           String
  filename         String
  originalFilename String
  bytes            BigInt
  originalBytes    BigInt
  host             String
  progress         Int
  status           String
  ended            DateTime
  updatedAt        DateTime        @updatedAt
  season           Int?
  episode          Int?
  files            AvailableFile[]

  @@index([status])
  @@index([imdbId])
  @@index([imdbId, hash])
  @@index([imdbId, status, season, episode, bytes])
}

model AvailableFile {
  link      String    @id
  file_id   Int
  hash      String
  path      String    @db.Text
  bytes     BigInt
  season    Int?
  episode   Int?
  available Available @relation(fields: [hash], references: [hash], onDelete: Cascade)

  @@index([hash])
  @@index([hash, season, episode])
}

model AvailableAd {
  hash              String            @id
  imdbId            String
  filename          String
  originalFilename  String
  bytes             BigInt
  originalBytes     BigInt
  host              String
  progress          Int
  status            String
  statusCode        Int?
  ended             DateTime
  updatedAt         DateTime          @updatedAt
  createdAt         DateTime          @default(now())
  season            Int?
  episode           Int?
  verifiedAt        DateTime          @default(now())
  verificationCount Int               @default(1)
  files             AvailableAdFile[]

  @@index([status])
  @@index([imdbId])
  @@index([imdbId, hash])
  @@index([imdbId, status, season, episode, bytes])
  @@index([updatedAt])
}

model AvailableAdFile {
  link        String      @id
  file_id     Int
  hash        String
  path        String      @db.Text
  bytes       BigInt
  season      Int?
  episode     Int?
  availableAd AvailableAd @relation(fields: [hash], references: [hash], onDelete: Cascade)

  @@index([hash])
  @@index([hash, season, episode])
}

model User {
  id        Int     @id @default(autoincrement())
  patreonId String? @unique
  githubId  String? @unique
  discordId String? @unique

  patreonSubscription PatreonSubscription?
}

model PatreonSubscription {
  id               Int      @id @default(autoincrement())
  tier             String
  perks            String
  subscriptionDate DateTime @default(now())

  userId Int  @unique
  user   User @relation(fields: [userId], references: [id])
}

model Report {
  id        Int      @id @default(autoincrement())
  hash      String
  imdbId    String
  userId    String
  type      String // "porn" or "wrong_imdb" or "wrong_season"
  createdAt DateTime @default(now())

  @@unique([hash, userId])
  @@index([imdbId])
  @@index([hash])
}

model TrackerStats {
  hash               String   @id
  seeders            Int      @default(0)
  leechers           Int      @default(0)
  downloads          Int      @default(0)
  successfulTrackers Int      @default(0)
  totalTrackers      Int      @default(0)
  lastChecked        DateTime @default(now())

  @@index([lastChecked])
}

model TorrentSnapshot {
  id        String   @id
  hash      String
  addedDate DateTime
  payload   Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([hash])
  @@index([hash, addedDate])
}

model MdblistCache {
  id        String   @id
  type      String // "movie", "show", "search", "list", etc.
  data      Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([type])
  @@index([updatedAt])
}

model ZurgKeys {
  apiKey     String    @id
  validUntil DateTime?
  createdAt  DateTime  @default(now())

  @@index([validUntil])
}

// Stream server health check results
// Stores the latest health check for each server
model StreamServerHealth {
  host      String   @id // e.g., "1.download.real-debrid.com"
  status    Int?
  latencyMs Float?
  ok        Boolean  @default(false)
  error     String?  @db.Text
  checkedAt DateTime
  updatedAt DateTime @updatedAt

  @@index([ok])
  @@index([latencyMs])
  @@index([checkedAt])
}

// ═══════════════════════════════════════════════════════════════
// HISTORICAL DATA FOR 90-DAY OBSERVABILITY
// ═══════════════════════════════════════════════════════════════

// RD Operations - Hourly aggregates (kept for 7 days, then rolled into daily)
// This table is updated via atomic increments, no raw events stored
model RdOperationalHourly {
  id           Int      @id @default(autoincrement())
  hour         DateTime // Start of hour (UTC), e.g., 2024-01-15T14:00:00Z
  operation    String   // "GET /user", "GET /torrents", etc.
  totalCount   Int      @default(0) // Total requests in this hour
  successCount Int      @default(0) // 2xx responses
  failureCount Int      @default(0) // 5xx responses
  otherCount   Int      @default(0) // 3xx, 4xx (not counted in availability)
  successRate  Float    @default(0) // Pre-computed: successCount / (successCount + failureCount)
  createdAt    DateTime @default(now())

  @@unique([hour, operation])
  @@index([hour])
  @@index([operation, hour])
}

// RD Operations - Daily aggregates (kept for 90 days)
model RdOperationalDaily {
  id             Int      @id @default(autoincrement())
  date           DateTime // Start of day (UTC)
  operation      String
  totalCount     Int      // Sum of hourly totals
  successCount   Int
  failureCount   Int
  avgSuccessRate Float    // Average of hourly success rates
  minSuccessRate Float    // Worst hour of the day
  maxSuccessRate Float    // Best hour of the day
  peakHour       Int?     // Hour with most traffic (0-23)
  createdAt      DateTime @default(now())

  @@unique([date, operation])
  @@index([date])
  @@index([operation, date])
}

// Stream Health - Individual check results (kept for 24 hours, last 50 max)
model StreamCheckResult {
  id        Int      @id @default(autoincrement())
  ok        Boolean  // Whether the check passed
  latencyMs Float?   // Latency if passed
  server    String?  // Server that was tested
  error     String?  // Error message if failed
  checkedAt DateTime @default(now())

  @@index([checkedAt])
}

// Torrentio Health - Individual check results (kept last 50 max)
model TorrentioCheckResult {
  id        Int      @id @default(autoincrement())
  ok        Boolean  // Whether all 3 URLs returned 302 with real-debrid in location
  latencyMs Float?   // Average latency across the 3 checks
  error     String?  @db.Text // Error message if failed
  urls      Json     @default("[]") // Results for each URL: [{url, ok, status, hasLocation}]
  checkedAt DateTime @default(now())

  @@index([checkedAt])
}

// Torrentio Health - Hourly snapshots (kept for 7 days)
model TorrentioHealthHourly {
  id           Int      @id @default(autoincrement())
  hour         DateTime // Start of hour (UTC)
  successCount Int      @default(0) // Number of successful checks in hour
  totalCount   Int      @default(0) // Total checks in hour
  successRate  Float    @default(0) // successCount / totalCount
  avgLatencyMs Float?   // Average latency of checks
  createdAt    DateTime @default(now())

  @@unique([hour])
  @@index([hour])
}

// Torrentio Health - Daily aggregates (kept for 90 days)
model TorrentioHealthDaily {
  id             Int      @id @default(autoincrement())
  date           DateTime // Start of day (UTC)
  avgSuccessRate Float    // Average success rate across all checks
  minSuccessRate Float    // Worst hour of the day
  maxSuccessRate Float    // Best hour of the day
  avgLatencyMs   Float?   // Average latency across all checks
  checksCount    Int      // Total health checks that day
  createdAt      DateTime @default(now())

  @@unique([date])
  @@index([date])
}

// Stream Health - Hourly snapshots (kept for 7 days)
model StreamHealthHourly {
  id             Int      @id @default(autoincrement())
  hour           DateTime // Start of hour (UTC)
  totalServers   Int      // Always 360
  workingServers Int      // How many passed all 3 iterations
  workingRate    Float    // workingServers / totalServers
  avgLatencyMs   Float?   // Average latency of working servers
  minLatencyMs   Float?   // Fastest server latency
  maxLatencyMs   Float?   // Slowest working server latency
  fastestServer  String?  // Hostname of fastest server
  checksInHour   Int      @default(1) // Number of checks aggregated
  failedServers  Json     @default("[]") // Array of failed server hostnames
  createdAt      DateTime @default(now())

  @@unique([hour])
  @@index([hour])
}

// Stream Health - Daily aggregates (kept for 90 days)
model StreamHealthDaily {
  id             Int      @id @default(autoincrement())
  date           DateTime // Start of day (UTC)
  avgWorkingRate Float    // Average % of servers working across all checks
  minWorkingRate Float    // Worst check of the day
  maxWorkingRate Float    // Best check of the day
  avgLatencyMs   Float?   // Average latency across all checks
  checksCount    Int      // Total health checks that day
  alwaysWorking  Int      @default(0) // Servers that never failed
  neverWorking   Int      @default(0) // Servers that never worked
  flaky          Int      @default(0) // Intermittent servers
  createdAt      DateTime @default(now())

  @@unique([date])
  @@index([date])
}

// Per-server daily reliability (for server-level analysis)
model ServerReliabilityDaily {
  id           Int      @id @default(autoincrement())
  date         DateTime
  host         String   // Server hostname
  checksCount  Int      // Times checked
  successCount Int      // Times it was working
  avgLatencyMs Float?   // Average latency when working
  reliability  Float    // successCount / checksCount
  createdAt    DateTime @default(now())

  @@unique([date, host])
  @@index([date])
  @@index([host])
  @@index([reliability])
}

// ═══════════════════════════════════════════════════════════════
// IMDB DATA TABLES
// ═══════════════════════════════════════════════════════════════

model ImdbTitleBasics {
  tconst         String   @id @map("tconst") @db.VarChar(12)
  titleType      String   @map("title_type") @db.VarChar(20)
  primaryTitle   String?  @map("primary_title") @db.VarChar(500)
  originalTitle  String?  @map("original_title") @db.VarChar(500)
  isAdult        Boolean? @default(false) @map("is_adult")
  startYear      Int?     @map("start_year") @db.UnsignedSmallInt
  endYear        Int?     @map("end_year") @db.UnsignedSmallInt
  runtimeMinutes Int?     @map("runtime_minutes") @db.UnsignedInt

  @@index([titleType], map: "idx_title_type")
  @@index([isAdult], map: "idx_is_adult")
  @@index([startYear], map: "idx_start_year")
  @@fulltext([primaryTitle], map: "ft_primary_title")
  @@map("imdb_title_basics")
}

model ImdbTitleAkas {
  id              Int      @id @default(autoincrement()) @db.UnsignedInt
  titleId         String   @map("title_id") @db.VarChar(12)
  ordering        Int      @db.UnsignedSmallInt
  title           String?  @db.Text
  region          String?  @db.VarChar(10)
  language        String?  @db.VarChar(10)
  types           String?  @db.Text
  attributes      String?  @db.Text
  isOriginalTitle Boolean? @default(false) @map("is_original_title")

  @@unique([titleId, ordering], map: "uk_title_ordering")
  @@index([region], map: "idx_region")
  @@index([language], map: "idx_language")
  @@fulltext([title], map: "ft_title")
  @@map("imdb_title_akas")
}

model ImdbTitleRatings {
  tconst        String  @id @map("tconst") @db.VarChar(12)
  averageRating Decimal @map("average_rating") @db.Decimal(3, 1)
  numVotes      Int     @map("num_votes") @db.UnsignedInt

  @@index([averageRating], map: "idx_rating")
  @@index([averageRating, numVotes], map: "idx_rating_votes")
  @@index([numVotes], map: "idx_votes")
  @@map("imdb_title_ratings")
}

model ImdbTitleEpisode {
  tconst        String @id @db.VarChar(12)
  parentTconst  String @map("parent_tconst") @db.VarChar(12)
  seasonNumber  Int?   @map("season_number") @db.UnsignedSmallInt
  episodeNumber Int?   @map("episode_number") @db.UnsignedInt

  @@index([parentTconst], map: "idx_parent")
  @@index([parentTconst, seasonNumber, episodeNumber], map: "idx_season_episode")
  @@map("imdb_title_episode")
}

model ImdbTitleGenres {
  titleId String @map("title_id") @db.VarChar(12)
  genreId Int    @map("genre_id") @db.UnsignedSmallInt

  @@id([titleId, genreId])
  @@index([genreId], map: "fk_tg_genre")
  @@map("imdb_title_genres")
}

model ImdbGenres {
  id   Int    @id @default(autoincrement()) @db.UnsignedSmallInt
  name String @unique(map: "name") @db.VarChar(50)

  @@map("imdb_genres")
}

model ImdbNameBasics {
  nconst      String  @id @db.VarChar(12)
  primaryName String? @map("primary_name") @db.VarChar(255)
  birthYear   Int?    @map("birth_year") @db.UnsignedSmallInt
  deathYear   Int?    @map("death_year") @db.UnsignedSmallInt

  @@index([birthYear], map: "idx_birth_year")
  @@map("imdb_name_basics")
}

model ImdbNameKnownTitles {
  nameId  String @map("name_id") @db.VarChar(12)
  titleId String @map("title_id") @db.VarChar(12)

  @@id([nameId, titleId])
  @@index([titleId], map: "idx_title")
  @@map("imdb_name_known_titles")
}

model ImdbNameProfessions {
  nameId       String @map("name_id") @db.VarChar(12)
  professionId Int    @map("profession_id") @db.UnsignedSmallInt

  @@id([nameId, professionId])
  @@index([professionId], map: "fk_np_profession")
  @@map("imdb_name_professions")
}

model ImdbProfessions {
  id   Int    @id @default(autoincrement()) @db.UnsignedSmallInt
  name String @unique(map: "name") @db.VarChar(100)

  @@map("imdb_professions")
}

// ═══════════════════════════════════════════════════════════════
// SPONSORSHIP & ACCESS TABLES
// ═══════════════════════════════════════════════════════════════

model DonationHistory {
  id             String   @id
  createdAt      DateTime @default(now())
  githubUsername String
  amountInCents  Int
  donationDate   DateTime @default(now())
  donationMethod String
  transactionId  String?
  notes          String?
  durationDays   Int
  endDate        DateTime

  @@index([donationDate])
  @@index([githubUsername, createdAt])
}

model PatreonUsageHistory {
  id             String    @id
  createdAt      DateTime  @default(now())
  patreonUserId  String
  githubUsername String
  action         String
  cooldownUntil  DateTime?

  @@index([githubUsername])
  @@index([patreonUserId, createdAt])
}

model RepoAccess {
  id             String    @id
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  githubUsername String
  repoOwner      String
  repoName       String
  hasAccess      Boolean   @default(true)
  grantedAt      DateTime  @default(now())
  revokedAt      DateTime?
  grantReason    String?
  revokeReason   String?

  @@unique([githubUsername, repoOwner, repoName])
  @@index([githubUsername])
  @@index([hasAccess, updatedAt])
  @@index([repoOwner, repoName, hasAccess])
}

model Sponsors {
  id                     String    @id
  shortId                String    @unique
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt
  githubUsername         String    @unique
  githubSponsoring       Boolean   @default(false)
  patreonUserId          String?   @unique
  patreonEmail           String?
  patreonAmount          Int       @default(0)
  oneTimeDonationAmount  Int?
  oneTimeDonationDate    DateTime?
  oneTimeDonationEndDate DateTime?
  discordUserId          String?   @unique
  discordUsername        String?
  zurgApiKey             String?   @unique
  zurgApiKeyVersion      Int       @default(1)

  @@index([githubSponsoring, patreonAmount])
  @@index([updatedAt])
}

model TempAuthData {
  id              String   @id
  token           String   @unique
  createdAt       DateTime @default(now())
  githubUsername  String?
  githubId        String?
  patreonUserId   String?
  patreonEmail    String?
  patreonFullName String?
  discordUserId   String?
  discordUsername String?
  expiresAt       DateTime

  @@index([expiresAt])
  @@index([token])
}
